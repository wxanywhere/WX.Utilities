Search key word
word TablesOfContents.add c#

OpenXML: How to refresh a field when the document is opened
http://www.samuraiprogrammer.com/blog/2010/08/09/OpenXMLHowToRefreshAFieldWhenTheDocumentIsOpened.aspx

openxml sdk 2.5 create Toc

Fourth and Final Screen-Cast in Series on Adding/Updating the TOC in OpenXML WordprocessingML Documents
http://ericwhite.com/blog/2011/08/22/fourth-and-final-screen-cast-in-series-on-addingupdating-the-toc-in-openxml-wordprocessingml-documents/

Replace bookmark text in Word file using Open XML SDK
http://stackoverflow.com/questions/3308299/replace-bookmark-text-in-word-file-using-open-xml-sdk
  IDictionary<String, BookmarkStart> bookmarkMap = 
      new Dictionary<String, BookmarkStart>();

  foreach (BookmarkStart bookmarkStart in file.MainDocumentPart.RootElement.Descendants<BookmarkStart>())
  {
      bookmarkMap[bookmarkStart.Name] = bookmarkStart;
  }

  foreach (BookmarkStart bookmarkStart in bookmarkMap.Values)
  {
      Run bookmarkText = bookmarkStart.NextSibling<Run>();
      if (bookmarkText != null)
      {
          bookmarkText.GetFirstChild<Text>().Text = "blah";
      }
  }

Word processing (Open XML SDK 2.5)
http://msdn.microsoft.com/en-us/library/cc850833.aspx

Open XML SDK 2.5 类库参考
http://msdn.microsoft.com/zh-cn/library/office/gg278315.aspx

字处理 (Open XML SDK)
http://msdn.microsoft.com/zh-cn/library/office/cc850833.aspx

Open XML SDK 2.5 for Office 中的新增功能
http://msdn.microsoft.com/zh-cn/library/office/cc471858.aspx

Open XML Format SDK
http://social.msdn.microsoft.com/Forums/zh-TW/oxmlsdk/threads?filter=alltypes&sort=viewsdesc

Exploring Tables-of-Contents in Open XML WordprocessingML Documents
http://openxmldeveloper.org/blog/b/openxmldeveloper/archive/2011/08/08/exploring-tables-of-contents-in-open-xml-wordprocessingml-documents.aspx

使用 Open XML SDK 2.0 检索 Word 2010 文档中目录
http://msdn.microsoft.com/zh-cn/library/gg308473.aspx

How to update word (.docx) TOC
http://openxmldeveloper.org/discussions/formats/f/13/t/1859.aspx

How to generate Table Of Contents using OpenXML SDK 2.0?
http://stackoverflow.com/questions/9762684/how-to-generate-table-of-contents-using-openxml-sdk-2-0

Can anyone tell me how to update word table of contents using Open XML SDK 2.0 dynamically.
http://openxmldeveloper.org/discussions/formats/f/13/t/1859.aspx
Hi,
 
It is working fine. Check out the following Steps:
 ◦Use the TOC Region code as written in the ealier blog
 ◦Use a template to create the doc. Instead of creating a new doc use exisiting doc template.To create a new template follow the steps:
 ■Create a new doc in Word 2007
 ■The doc template should contain a TOC. To add toc in word 2007 follow the steps:
 ■Reference-->Table of content-->Automatic table 1
 ■Now Just below the Table of content Add a Header(Heading1) and write something. 
■Update the TOC.Chck the TOCshould be updated
 ■Delete the Header, which you have written. Do not touch the TOC.
 ■Save the Doc an close it.
 ◦Now follow the following code:
 
static XNamespace ns = "http://schemas.openxmlformats.org/wordprocessingml/2006/main";
    
public void generateWordDocument()
        {
     WindowsIdentity currentUserIdentity = (WindowsIdentity)User.Identity;
            WindowsImpersonationContext impersonationContext = currentUserIdentity.Impersonate();
            try
            {
         string fileName = currentUserIdentity.Name.Replace("\\", "_") + "_Report.docx";
                string filePath = @"D:\Personals\Sudip\" + fileName;
                File.Copy(@"D:\Personals\Sudip\Contents.docx", filePath);
  using (WordprocessingDocument wordDoc = WordprocessingDocument.Open(filePath, true))
                {
                    MainDocumentPart mainPart = wordDoc.MainDocumentPart;
 
      //Create Document tree for simple document. 
                    mainPart.Document = new Document();
                    //Create Body (this element contains other elements that we want to include 
                    Body body = new Body();
                
      //This body should contain Headers.
      
                    //Save changes to the main document part. 
                    mainPart.Document.Append(body);
 
      XDocument xmlXdocument = XDocument.Parse(mainPart.Document.InnerXml);
                    IEnumerable<XElement> xmlelement = xmlXdocument.Descendants(ns + "sdt");
                    XElement TOCRefNode = xmlelement.First();
                    GenerateTOC(xmlXdocument, TOCRefNode);
 
                    mainPart.Document.InnerXml = xmlXdocument.ToString();
 
                    mainPart.Document.Save();
      wordDoc.Close();
  }
   
     }
 }
 
#region TOC Creation
            /// <summary>
            /// returns title paragraphs of genereated doc fro creating toc hyperlink
            /// </summary>
        private static IEnumerable<XElement> TitleParagraphsElements(XDocument mainDocument)
        {
            IEnumerable<XElement> results = mainDocument.Descendants().Where
              (
                  tag =>
                      tag.Name == ns + "p" &&
                      tag.Descendants(ns + "t").Count() > 0 &&
                      tag.Descendants().Where
                      (
                        tag2 =>
                            tag2.Name == ns + "pStyle" &&
                            (
                                tag2.Attribute(ns + "val").Value == "Head1" ||
                                tag2.Attribute(ns + "val").Value == "Head2" ||
                                tag2.Attribute(ns + "val").Value == "Head3" ||
                                tag2.Attribute(ns + "val").Value == "Head4" ||
                                tag2.Attribute(ns + "val").Value == "Head5" ||
                                tag2.Attribute(ns + "val").Value == "Head6" ||
                                tag2.Attribute(ns + "val").Value == "Heading1"||
                                tag2.Attribute(ns + "val").Value == "Heading2"
                            )
                      ).Count() > 0
              );
 
            return results;
        }
 
        private static  void GenerateTOC(XDocument xmlMainDocument, XElement TOCRefNode)
        {
            int bookMarkIdCounter = 0;
            int maxHeading = 1;
            int tempheading = 1;
 
            //  sdtContent, will contain all the paragraphs used in the TOC
            XElement sdtContent = new XElement(ns + "sdtContent");
            String strContentHdr = "";
            XElement xContentHdr = TOCRefNode.Elements(ns + "sdtContent").First().Descendants().Where(
                tag =>
                    tag.Name == ns + "p" &&
                    tag.Descendants().Where
                    (
                        tag2 =>
                            tag2.Name == ns + "pStyle" &&
                            tag2.Attribute(ns + "val").Value == "TOCHeading"
                    ).Count() > 0
                ).FirstOrDefault();
 
            if (xContentHdr != null)
                strContentHdr = xContentHdr.Descendants(ns + "t").FirstOrDefault().Value;
 
            //  some information regarding the attributes of the TOC
            xContentHdr.Add(
 
                        new XElement(ns + "r",
                            new XElement(ns + "fldChar",
                                    new XAttribute(ns + "fldCharType", "begin"))),
                        new XElement(ns + "r",
                            new XElement(ns + "instrText",
                                new XAttribute(XNamespace.Xml + "space", "preserve"),
                                "TOCLIMIT")),
                        new XElement(ns + "r",
                            new XElement(ns + "fldChar",
                                new XAttribute(ns + "fldCharType", "separate"))));
            sdtContent.Add(new XElement(xContentHdr));
 

            //  for each title found it in the document, we have to wrap the run inside of it,
            //  with a bookmark, this bookmark will have an id which will work as an anchor,
            //  for link references in the TOC
            foreach (XElement titleParagraph in TitleParagraphsElements(xmlMainDocument))
            {
                string bookmarkName = "_TOC" + bookMarkIdCounter;
                XElement bookmarkStart =
                    new XElement(ns + "bookmarkStart",
                        new XAttribute(ns + "id", bookMarkIdCounter),
                        new XAttribute(ns + "name", bookmarkName));
                XElement bookmarkEnd =
                    new XElement(ns + "bookmarkEnd",
                        new XAttribute(ns + "id", bookMarkIdCounter));
 
                //  wrap the run with bookmarkStart and bookmarkEnd
                titleParagraph.AddFirst(bookmarkStart);
                titleParagraph.Add(bookmarkEnd);
 
                //  get the name of the style of the parapgraph of the title, and for each one,
                //  choose a style to add in the paragraph inside the TOC
                string referenceTitleStyle = "";
                switch (titleParagraph.Descendants(ns + "pStyle").First().Attribute(ns + "val").Value)
                {
                    case "Head1":
                        {
                            referenceTitleStyle = "TOC1";
                            tempheading = 1;
                            break;
                        }
                    case "Head2":
                        {
                            referenceTitleStyle = "TOC2";
                            tempheading = 2;
                            break;
                        }
                    case "Head3":
                        {
                            referenceTitleStyle = "TOC3";
                            tempheading = 3;
                            break;
                        }
                    case "Head4":
                        {
                            referenceTitleStyle = "TOC4";
                            tempheading = 4;
                            break;
                        }
                    case "Head5":
                        {
                            referenceTitleStyle = "TOC5";
                            tempheading = 5;
                            break;
                        }
                    case "Head6":
                        {
                            referenceTitleStyle = "TOC6";
                            tempheading = 6;
                            break;
                        }
          case "Heading1":
                        {
                            referenceTitleStyle = "TOC1";
                            tempheading = 6;
                            break;
                        }
                    case "Heading2":
                        {
                            referenceTitleStyle = "TOC2";
                            tempheading = 6;
                            break;
                        }
                }
 

                string entryContent = "";
                IEnumerable<XElement> owTList = titleParagraph.Descendants(ns + "t");
                foreach (XElement entryElement in owTList)
                {
                    entryContent += (entryElement == null ? string.Empty : entryElement.Value);
                }
 
                XElement TOCElement = null;
                XElement tempTOCElement = TOCRefNode.Elements(ns + "sdtContent").First().Descendants().Where(
                tag =>
                    tag.Name == ns + "p" &&
                    tag.Descendants().Where
                    (
                        tag2 =>
                            tag2.Name == ns + "pStyle" &&
                            tag2.Attribute(ns + "val").Value == referenceTitleStyle
                    ).Count() > 0
                ).FirstOrDefault();
 
                if (tempTOCElement != null)
                {
                    if (maxHeading < tempheading)
                        maxHeading = tempheading;
 
                    TOCElement = new XElement(tempTOCElement);
                    //delete instrText which contains TOC 1-n
                    XElement instrTextTOC = TOCElement.Descendants().Where(
                            tag =>
                                tag.Name == ns + "r" &&
                                tag.Descendants().Where(
                                    tag2 =>
                                        tag2.Name == ns + "instrText" &&
                                        tag2.Value.Contains(@"TOC \o ")
                                ).Count() > 0
 
                        ).FirstOrDefault();
                    if (instrTextTOC != null)
                    {
                        instrTextTOC.ElementsAfterSelf(ns + "r").Remove();
                        instrTextTOC.ElementsBeforeSelf(ns + "r").Remove();
                        instrTextTOC.Remove();
                    }
 
                    //get hyperlink node
                    XElement hyperlink = TOCElement.Descendants().Where(
                            tag =>
                                tag.Name == ns + "hyperlink"
 
                        ).FirstOrDefault();
                    //update anchor attribute value
                    hyperlink.Attribute(ns + "anchor").Value = bookmarkName;
 
                    //get entry content node
                    XElement contentNode = hyperlink.Descendants().Where(
                            tag =>
                                tag.Name == ns + "r" &&
                                tag.Descendants().Where(
                                    tag2 =>
                                        tag2.Name == ns + "rStyle" &&
                                        tag2.Attribute(ns + "val").Value == "Hyperlink"
                                ).Count() > 0 &&
                                tag.Elements(ns + "t").Count() > 0
 
                        ).FirstOrDefault().Elements(ns + "t").FirstOrDefault();
 
                    contentNode.Value = entryContent;
 
                    //update PAGEREF value
                    XElement instrText = TOCElement.Descendants().Where(
                            tag =>
                                tag.Name == ns + "instrText" &&
                                tag.Value.Contains("PAGEREF ")
                        ).FirstOrDefault();
                    if (instrText != null)
                    {
                        instrText.Value = " PAGEREF " + bookmarkName + @" \h ";
                    }
 
                    sdtContent.Add(TOCElement);
                    bookMarkIdCounter++;
                }
 

            }
 
            sdtContent.Descendants().Where(
                tag =>
                    tag.Name == ns + "instrText" 
                    &&
                    tag.Value.Contains("TOCLIMIT")
                ).FirstOrDefault().Value = String.Format(@"TOC \o ""1-{0}"" \h \z \u ", maxHeading);
 
            sdtContent.Add(
                new XElement(ns + "p",
                    new XElement(ns + "r",
                        new XElement(ns + "fldChar",
                            new XAttribute(ns + "fldCharType", "end")))));
 
            //  Finish the xml construction of the TOC
            XElement TOC =
                new XElement(ns + "sdt",
                    new XElement(ns + "sdtPr",
                        new XElement(ns + "docPartObj",
                            new XElement(ns + "docPartGallery",
                                new XAttribute(ns + "val", "Table of Contents")),
                            new XElement(ns + "docPartUnique"))),
                    sdtContent);
 
            //  add it to the original document
 
            IEnumerable<XElement> tocNodes = xmlMainDocument.Descendants().Where
              (
                  tag =>
                      tag.Name == ns + "sdt" &&
                      tag.Descendants(ns + "sdtContent").Count() > 0 &&
                      tag.Descendants().Where
                      (
                        tag2 =>
                            tag2.Name == ns + "p" &&
                            tag2.Descendants().Where
                            (
                                tag3 =>
                                    tag3.Name == ns + "pStyle" &&
                                        (
                                            tag3.Attribute(ns + "val").Value == "TOCHeading"
                                        )
                            ).Count() > 0
 
                      ).Count() > 0
              );
 
            TOCRefNode.ReplaceWith(TOC);
 
        }
 

        #endregion





使用OpenXml SDK向Word文档中添加页、段落、页眉和页脚 
http://blog.csdn.net/songpengpeng20100202/article/details/7071030

down vote
 I find Code That Worked Correct I Test Very way To this Action Only This code is Usefull
  http://stackoverflow.com/questions/8082980/inserting-image-into-docx-using-openxml-and-setting-the-size

    public static void Do()
    {
        string filename = @"c:\temp\m.docx";
        byte[] reportData = GetWordReport();
       // File.WriteAllBytes(filename, reportData);
        //MessageBox.Show("File " + filename + " created");
    }

    private static byte[] GetWordReport()
    {
       // using (MemoryStream stream = new MemoryStream())
       // {
            //var template = GetTemplateData();
            //stream.Write(template, 0, template.Length);
            using (WordprocessingDocument docx = WordprocessingDocument.Open(@"c:\temp\m.docx", true))
            {
                // Some changes on docx
                docx.MainDocumentPart.Document = GenerateMainDocumentPart(6,4);

                var imagePart = docx.MainDocumentPart.AddNewPart<ImagePart>("image/jpeg", "rIdImagePart1");
                GenerateImagePart(imagePart);
            }
          //  stream.Seek(0, SeekOrigin.Begin);
           // return stream.ToArray();
       // }
        return null;
    }

    private static byte[] GetTemplateData()
    {
        using (MemoryStream targetStream = new MemoryStream())
        using (BinaryReader sourceReader = new BinaryReader(File.Open(@"c:\temp\m_2.docx", FileMode.Open)))
        {
            byte[] buffer = new byte[4096];

            int num = 0;
            do
            {
                num = sourceReader.Read(buffer, 0, 4096);
                if (num > 0)
                    targetStream.Write(buffer, 0, num);
            }
            while (num > 0);
            targetStream.Seek(0, SeekOrigin.Begin);
            return targetStream.ToArray();
        }
    }

    private static void GenerateImagePart(OpenXmlPart part)
    {
        using (Stream imageStream = File.Open(@"c:\temp\image002.jpg", FileMode.Open))
        {
            part.FeedData(imageStream);
        }
    }

    private static Document GenerateMainDocumentPart(int cx,int cy)
    {
        long LCX = cx*261257L;
        long LCY = cy*261257L;
        var element =
            new Document(
                new Body(
                    new Paragraph(
                        new Run(
                            new RunProperties(
                                new NoProof()),
                            new Drawing(
                                new wp.Inline(
                                    new wp.Extent() { Cx = LCX, Cy = LCY },
                                    new wp.EffectExtent() { LeftEdge = 0L, TopEdge = 19050L, RightEdge = 0L, BottomEdge = 0L },
                                    new wp.DocProperties() { Id = (UInt32Value)1U, Name = "Picture 0", Description = "Forest Flowers.jpg" },
                                    new wp.NonVisualGraphicFrameDrawingProperties(
                                        new a.GraphicFrameLocks() { NoChangeAspect = true }),
                                    new a.Graphic(
                                        new a.GraphicData(
                                            new pic.Picture(
                                                new pic.NonVisualPictureProperties(
                                                    new pic.NonVisualDrawingProperties() { Id = (UInt32Value)0U, Name = "Forest Flowers.jpg" },
                                                    new pic.NonVisualPictureDrawingProperties()),
                                                new pic.BlipFill(
                                                    new a.Blip() { Embed = "rIdImagePart1", CompressionState = a.BlipCompressionValues.Print },
                                                    new a.Stretch(
                                                        new a.FillRectangle())),
                                                new pic.ShapeProperties(
                                                    new a.Transform2D(
                                                        new a.Offset() { X = 0L, Y = 0L },
                                                        new a.Extents() { Cx = LCX, Cy = LCY }),
                                                    new a.PresetGeometry(
                                                        new a.AdjustValueList()
                                                    ) { Preset = a.ShapeTypeValues.Rectangle }))
                                        ) { Uri = "http://schemas.openxmlformats.org/drawingml/2006/picture" })
                                ) { DistanceFromTop = (UInt32Value)0U, DistanceFromBottom = (UInt32Value)0U, DistanceFromLeft = (UInt32Value)0U, DistanceFromRight = (UInt32Value)0U }))
                    ) { RsidParagraphAddition = "00A2180E", RsidRunAdditionDefault = "00EC4DA7" },
                    new SectionProperties(
                        new PageSize() { Width = (UInt32Value)11906U, Height = (UInt32Value)16838U },
                        new PageMargin() { Top = 1440, Right = (UInt32Value)1800U, Bottom = 1440, Left = (UInt32Value)1800U, Header = (UInt32Value)851U, Footer = (UInt32Value)992U, Gutter = (UInt32Value)0U },
                        new Columns() { Space = ((UInt32Value)425U).ToString() },
                        new DocGrid() { Type = DocGridValues.Lines, LinePitch = 312 }
                    ) { RsidR = "00A2180E", RsidSect = "00A2180E" }));
        return element;
    }
 

自己写的OpenXML 通用方法，改天自己好好整理一下写过的东西
http://hi.baidu.com/ggukknvsdcbbgxq/item/0d1a1bb286f30cd084dd797f

如何：在字处理文档中插入图片 (Open XML SDK)
http://msdn.microsoft.com/zh-cn/library/office/bb497430.aspx

How to: Insert a picture into a word processing document (Open XML SDK)
http://msdn.microsoft.com/en-us/library/bb497430.aspx

Adding Images to Documents in Word 2007 by Using the Open XML SDK 2.0 for Microsoft Office
http://msdn.microsoft.com/en-us/library/office/ee342530(v=office.12).aspx

MS OpenXML SDK 2.0在Excel中指定位置填入数据和插入图片 
http://www.cnblogs.com/mikelij/archive/2011/03/05/1971612.html

How to add items one at a time to to a new line a word document using word interop
http://stackoverflow.com/questions/12718044/how-to-add-items-one-at-a-time-to-to-a-new-line-a-word-document-using-word-inter

using System;
using System.IO;
using Microsoft.Office.Interop.Word;
using Application = Microsoft.Office.Interop.Word.Application;

namespace StackOverflowWordInterop
{
    class Program
    {
        static void Main()
        {
            // Open word and a docx file
            var wordApplication = new Application() { Visible = true };
            var document = wordApplication.Documents.Open(@"C:\Users\myUserName\Documents\document.docx", Visible: true);

            // "10" is chosen by random - select a value that fits your purpose
            for (var i = 0; i < 10; i++)
            {
                // Insert text
                var pText = document.Paragraphs.Add();
                pText.Format.SpaceAfter = 10f;
                pText.Range.Text = String.Format("This is line #{0}", i);
                pText.Range.InsertParagraphAfter();

                // Insert table
                var pTable = document.Paragraphs.Add();
                pTable.Format.SpaceAfter = 10f;
                var table = document.Tables.Add(pTable.Range, 2, 3, WdDefaultTableBehavior.wdWord9TableBehavior);
                for (var r = 1; r <= table.Rows.Count; r++)
                    for (var c = 1; c <= table.Columns.Count; c++)
                        table.Cell(r, c).Range.Text = String.Format("This is cell {0} in table #{1}", String.Format("({0},{1})", r,c) , i);

                // Insert picture
                var pPicture = document.Paragraphs.Add();
                pPicture.Format.SpaceAfter = 10f;
                document.InlineShapes.AddPicture(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments), "img_1.png"), Range: pPicture.Range);

            }

            // Some console ascii-UI
            Console.WriteLine("Press any key to save document and close word..");
            Console.ReadLine();

            // Save settings
            document.Save();

            // Close word
            wordApplication.Quit();
        }
    }
}


Insert Multiple Image in word file using c#
http://www.c-sharpcorner.com/uploadfile/hrojasara/insert-multiple-image-in-word-file-using-C-Sharp/

private void button1_Click(object sender, EventArgs e)

{

    // first we are creating application of word.

    Microsoft.Office.Interop.Word.Application WordApp = new Microsoft.Office.Interop.Word.Application();

    // now creating new document.

    WordApp.Documents.Add();

    // see word file behind your program

    WordApp.Visible = true;

    // get the reference of active document

    Microsoft.Office.Interop.Word.Document doc = WordApp.ActiveDocument;

    // set openfiledialog to select multiple image files

    OpenFileDialog ofd = new OpenFileDialog();

    ofd.Filter = "Images (*.BMP;*.JPG;*.GIF)|*.BMP;*.JPG;*.GIF";

    ofd.Title = "Select Image To Insert....";

    ofd.Multiselect = true;

    // if user select OK, then process for adding images

    if (ofd.ShowDialog() == DialogResult.OK)

    {

        // iterating process for adding all images which is selected by filedialog

        foreach (string filename in ofd.FileNames)

        {

            // now add the picture in active document reference

            doc.InlineShapes.AddPicture(filename, Type.Missing, Type.Missing, Type.Missing);

        }

    }

    // file is saved.

    doc.SaveAs("c:\\hello.doc", Type.Missing, Type.Missing, Type.Missing, Type.Missing, Type.Missing, Type.Missing, Type.Missing, Type.Missing, Type.Missing, Type.Missing, Type.Missing, Type.Missing, Type.Missing, Type.Missing, Type.Missing);

    // application is now quit.

    WordApp.Quit(Type.Missing, Type.Missing, Type.Missing);

}

Faster way to create word document in C# using Interop
http://stackoverflow.com/questions/12060810/faster-way-to-create-word-document-in-c-sharp-using-interop
Microsoft.Office.Interop.Word.Application WordApp = new Microsoft.Office.Interop.Word.Application();
Word.Document adoc;
Word.Range rng;
adoc = WordApp.Documents.Add(ref missing, ref missing, ref missing, ref missing);
rng = adoc.Range(ref start1, ref missing);

adoc.Tables.Add(rng, list.Count + 2, 4);
adoc.PageSetup.LeftMargin = 20.0f;
adoc.PageSetup.RightMargin = 20.0f;

adoc.Tables[1].Columns[2].Cells.PreferredWidth = 60;
adoc.Tables[1].Columns[1].Cells.PreferredWidth = 200;
adoc.Tables[1].Cell(1, 1).Range.Text = "Symbol";
adoc.Tables[1].Cell(1, 2).Range.Text = "Qnt";
adoc.Tables[1].Cell(1, 3).Range.Text = "Barcode";
adoc.Tables[1].Cell(1, 4).Range.Text = "Barcode Image";
adoc.Tables[1].Cell(1, 1).Range.ParagraphFormat.Alignment = Word.WdParagraphAlignment.wdAlignParagraphLeft;
adoc.Tables[1].Cell(1, 1).Range.Font.Bold = 1;
adoc.Tables[1].Cell(1, 2).Range.Font.Bold = 1;
adoc.Tables[1].Cell(1, 3).Range.Font.Bold = 1;
adoc.Tables[1].Cell(1, 4).Range.Font.Bold = 1;

for (int i = 0; i < list.Count; i++)
{

    adoc.Tables[1].Cell(i + 2, 1).Range.Text = list[i].symbol;
    adoc.Tables[1].Cell(i + 2, 2).Range.Text = list[i].qnt;
    adoc.Tables[1].Cell(i + 2, 3).Range.Text = list[i].code;
    adoc.Tables[1].Cell(i + 2, 4).Range.InlineShapes.AddPicture(list[i].code_picture, ref missing, ref missing, ref missing);
}

adoc.Tables[1].Range.Font.Size = 10;
adoc.Tables[1].Rows.Height = 2.0f;

#region Border
adoc.Tables[1].Borders[Word.WdBorderType.wdBorderLeft].LineStyle = Word.WdLineStyle.wdLineStyleSingle;
adoc.Tables[1].Borders[Word.WdBorderType.wdBorderTop].LineStyle = Word.WdLineStyle.wdLineStyleSingle;
adoc.Tables[1].Borders[Word.WdBorderType.wdBorderRight].LineStyle = Word.WdLineStyle.wdLineStyleSingle;
adoc.Tables[1].Borders[Word.WdBorderType.wdBorderBottom].LineStyle = Word.WdLineStyle.wdLineStyleSingle;
adoc.Tables[1].Borders[Word.WdBorderType.wdBorderHorizontal].LineStyle = Word.WdLineStyle.wdLineStyleSingle;
adoc.Tables[1].Borders[Word.WdBorderType.wdBorderVertical].LineStyle = Word.WdLineStyle.wdLineStyleSingle;
#endregion

try
{                       
    object filename = @"E:\Test.doc";
    adoc.SaveAs(ref filename, ref missing, ref missing, ref missing, ref missing, ref missing, 
        ref missing, ref missing, ref missing, ref missing, ref missing, ref missing, ref missing, ref missing, ref missing, ref missing);

    // Word.Table wt1 = WordApp.Selection.Tables.Add(WordApp.Selection.Range, 5, 2, ref missing, ref missing);
    //adoc.Tables[1].Rows.Add(adoc.Tables[1].Rows[1]);
    //WordApp.Visible = true;

    //adoc.Close();
    WordApp.Quit(ref missing, ref missing, ref missing);
}
catch (Exception ex)
{
    MessageBox.Show(ex.Message);
}


DocumentFormat.OpenXml.dll

E:\Program Files (x86)\Open XML SDK\V2.5\lib

Enable Word (docx) document track changes without Interop
http://stackoverflow.com/questions/14039135/enable-word-docx-document-track-changes-without-interop


Is it possible to update the TOC (TableOfContents) of a Word document generated with Syncfusion's DocIO lib?
http://stackoverflow.com/questions/3982624/is-it-possible-to-update-the-toc-tableofcontents-of-a-word-document-generated
Document wordDocument;
Microsoft.Office.Interop.Word.Application word = new Microsoft.Office.Interop.Word.Application(); 
wordDocument = word.Documents.Open(saveFileDialog.FileName);
wordDocument.TablesOfContents[1].Update();
wordDocument.Save();
word.Quit();



c# Interop Word Document add Style
http://stackoverflow.com/questions/9658717/c-sharp-interop-word-document-add-style

1down votefavorite

 


I want to add style to a paragraph, but depending on the word language version I have to use a different name. Now I'm creating an application for multiple users, and if they have an english version i can use "Header 1", but if they don't the style is not recognized. I was wondering what I should do, should I add a new style? I've been looking into this but I can't figure out how.

So on my dutch version i use:
selection.TypeParagraph();
object kop1 = "Kop1";
selection.set_Style(kop1);
selection.TypeText("test");

but english i need:
selection.TypeParagraph();
object kop1 = "Header 1";
selection.set_Style(kop1);
selection.TypeText("test");

I actually need this to create a content table, I can't create a content table if I don't use the styles, right? Otherwise my content tables says it has no content.

I make the content table using:
object start = adoc.Content.End - 1;
Range rangeForTOC = adoc.Range(ref start, ref missing);
TableOfContents toc = adoc.TablesOfContents.Add(rangeForTOC, ref missing, ref missing, ref missing, ref missing, ref missing, ref missing, ref missing, ref missing, ref missing, ref missing, ref missing);
adoc.TablesOfContents[1].TabLeader = WdTabLeader.wdTabLeaderDots;
adoc.TablesOfContents.Format = WdTocFormat.wdTOCClassic;
toc.Update();
 

 You might want to use Word.WdBuiltinStyle enumeration instead of language specific strings. For example use Word.WdBuiltinStyle.wdStyleHeading1 in your above code.

Another way to solve this issue is to add your own template and use the styles defined in that template. In this case you supply your template in your distribution.

For using pre-defined table generation styles, also see this answer: Setting Word 2007 table style designs in code


How to create table of contents via C#? 
http://social.msdn.microsoft.com/Forums/en-US/vsto/thread/60531aa8-ef5c-4e88-9728-3f8b85caab7c/
Object missing = Type.Missing;

            Object openobj = @"C:\temp\p2.doc";

            Microsoft.Office.Interop.Word.Application wordApp = new Microsoft.Office.Interop.Word.Application();

            Document docx= wordApp.Documents.Open(ref openobj, ref missing, ref missing, ref missing, ref missing, ref missing, ref missing, ref missing, ref missing, ref missing, ref missing, ref missing, ref missing, ref missing, ref missing, ref missing);

            foreach (Section s in docx.Sections)

            {

                Object fieldType = WdFieldType.wdFieldTOCEntry;

                for (int i = 1; i <= s.Headers[WdHeaderFooterIndex.wdHeaderFooterPrimary].Shapes.Count; i++)

                {

                    string stext = "";

                    Object oi = i;

                    Microsoft.Office.Interop.Word.Shape sp = s.Headers[WdHeaderFooterIndex.wdHeaderFooterPrimary].Shapes.get_Item(ref oi);

                    if ((int)sp.Type == 17)  // 17 is Text Box

                    {

                        stext = sp.TextFrame.TextRange.Text.Trim();

                        if (stext != "")

                        {

                            Object textValue = stext ;

                            Object dir = WdCollapseDirection.wdCollapseEnd;

                            Object targetRange = s.Range;

                            Paragraph pr = s.Range.Paragraphs.Add(ref targetRange);

                            //pr.Range.Collapse(ref dir);

                            docx.TablesOfContents[1].UseFields = true;

                            Field f = s.Range.Fields.Add(pr.Range, ref fieldType, ref missing, ref missing);

                        }

                    }

                }

 

            }

            docx.TablesOfContents[1].Update();

            docx.Save();

            wordApp.Quit(ref missing, ref missing, ref missing);

 

        } 

Creating and Updating table of contents in word document using C#
http://nishantrana.wordpress.com/2008/07/17/creating-and-updating-table-of-contents-in-word-document-using-c/
// For optional parameters create a missing object

object missing = System.Reflection.Missing.Value;

// Create an object for filename which is the file to be opened 

object fileName = @”C:\MySecond.doc”;

// Create an object of application class

ApplicationClass WordApp = new ApplicationClass();

// open the document specified in the fileName variable

Document adoc = WordApp.Documents.Open(ref fileName, ref missing, ref missing, ref missing, ref missing,

ref missing, ref missing, ref missing, ref missing, ref missing, ref missing, ref missing, ref missing,

ref missing, ref missing, ref missing);



Range myRange = adoc.Range(ref missing, ref missing);

myRange.InsertAfter(“Hello Mickey Mouse GG “);



object oStyleName = “Heading 1″;

myRange.set_Style(ref oStyleName);



object start=WordApp.ActiveDocument.Content.End – 1;

Range rangeForTOC = adoc.Range(ref start, ref missing);

TableOfContents toc=adoc.TablesOfContents.Add(rangeForTOC, ref missing, ref missing, ref missing, ref missing, ref missing,ref missing, ref missing, ref missing, ref missing, ref missing, ref missing);



toc.Update();

Range rngTOC = toc.Range;

rngTOC.Font.Size = 10;

rngTOC.Font.Name = “Georgia“;

WordApp.Visible = true;


How to use Heading Style while automating word in C#?
http://stackoverflow.com/questions/5937434/how-to-use-heading-style-while-automating-word-in-c
object headingType = Word.WdBuiltinStyle.wdStyleHeading2;
wordApp.ActiveWindow.Selection.Range.PasteAndFormat(WdRecoveryType.wdPasteDefault);
wordApp.ActiveWindow.Selection.Range.set_Style(ref headingType);


Insert Header in Word Document – C#/VB.NET
http://www.zimbio.com/Microsoft+Word/articles/4wnkuBBmOgA/Insert+Header+Word+Document+C+VB+NET

Main Coding:

C#

using System;

using System.Drawing;

using Spire.Doc;

using Spire.Doc.Documents;

using Spire.Doc.Fields;

namespace InsertHeader

{

    class header

    {

        static void Main(string[] args)

        {

            //Load Document

            Document document = new Document();

            document.LoadFromFile(@”D:\work\My Documents\Little Prince.docx”);

            Section section = document.AddSection();

            //Insert Header

            HeaderFooter header = section.HeadersFooters.Header;

            Paragraph headerParagraph = header.AddParagraph();

            TextRange text = headerParagraph.AppendText(“Little Prince”);

            text.CharacterFormat.FontName = “Calibri”;

            text.CharacterFormat.FontSize = 14;

            text.CharacterFormat.TextColor = Color.DarkSlateGray;

            headerParagraph.Format.HorizontalAlignment

                = Spire.Doc.Documents.HorizontalAlignment.Right;

            headerParagraph.Format.Borders.Bottom.BorderType

                = Spire.Doc.Documents.BorderStyle.Single;

            headerParagraph.Format.Borders.Bottom.Space = 0.1F;

            //Save

            document.SaveToFile(“Header.docx”, FileFormat.Docx);

            //Launch

            System.Diagnostics.Process.Start(“Header.docx”);

        }

    }

}



open System.IO

#I @"E:\Program Files (x86)\Open XML SDK\V2.5\lib"
#r "DocumentFormat.OpenXml"
#r "WindowsBase"
open DocumentFormat.OpenXml
open DocumentFormat.OpenXml.Packaging
open DocumentFormat.OpenXml.Wordprocessing
open DocumentFormat.OpenXml.Drawing
open DocumentFormat.OpenXml.Drawing.Wordprocessing
open DocumentFormat.OpenXml.Drawing.Pictures
//------------------------------------------------------------
let filePath= @"d:\Temp\Testing\TestDoc.docx"

let byteArray = File.ReadAllBytes filePath

let memory=new MemoryStream() 
let doc=WordprocessingDocument.Create(filePath,WordprocessingDocumentType.Document)
doc.Close()
memory.Close()

let fs=new FileStream(filePath, FileMode.Create)
memory.WriteTo fs
fs.Close()

let main= doc.AddMainDocumentPart()
main.Document<-new Document()
let body = main.Document.AppendChild(new Body())
// 建立 Paragraph 類別物件，於 Body 本文中加入段落 Paragraph(p)
let paragraph = body.AppendChild(new Paragraph())
// 建立 Run 類別物件，於 段落 Paragraph(p) 中加入文字屬性 Run(r) 範圍
let run = paragraph.AppendChild(new Run())
// 在文字屬性 Run(r) 範圍中加入文字內容
run.AppendChild(new Text("在 body 本文內容產生 text 文字"))
main.Document.Save()

let docx=WordprocessingDocument.Open(filePath,true)
docx.Close()
docx.MainDocumentPart.Document.Body.InnerText

let image=main.AddImagePart(ImagePartType.Png)
let stream = new FileStream(@"D:\Temp\Testing\x.png", FileMode.Open)
image.FeedData stream
stream.Close()

let element =
     new Drawing(
         new Inline(
             new Extent(Cx = 990000L, Cy = 792000L ),
             new EffectExtent( LeftEdge = 0L, TopEdge = 0L, RightEdge = 0L, BottomEdge = 0L ),
             new DocProperties( Id = 1:?>UInt32Value, Name = "Picture 1" ),
             new NonVisualGraphicFrameDrawingProperties(new GraphicFrameLocks(NoChangeAspect = true)),
             new Graphic(
                 new GraphicData(
                     new Picture(
                         new NonVisualPictureProperties(
                             new NonVisualDrawingProperties(Id = 0:?>UInt32Value, Name = "New Bitmap Image.jpg" ),
                             new NonVisualPictureDrawingProperties()),
                         new BlipFill(
                             new Blip(
                                 new BlipExtensionList(
                                     new BlipExtension(Uri = "{28A0092B-C50C-407E-A947-70E740481C1C}")) 
                             { Embed = relationshipId, 
                                 CompressionState = 
                                 A.BlipCompressionValues.Print },
                             new A.Stretch(
                                 new A.FillRectangle())),
                         new PIC.ShapeProperties(
                             new A.Transform2D(
                                 new A.Offset() { X = 0L, Y = 0L },
                                 new A.Extents() { Cx = 990000L, Cy = 792000L }),
                             new A.PresetGeometry(
                                 new A.AdjustValueList()
                             ) { Preset = A.ShapeTypeValues.Rectangle }))
                 ) { Uri = "http://schemas.openxmlformats.org/drawingml/2006/picture" })
         ) { DistanceFromTop = (UInt32Value)0U, 
             DistanceFromBottom = (UInt32Value)0U, 
             DistanceFromLeft = (UInt32Value)0U, 
             DistanceFromRight = (UInt32Value)0U, EditId = "50D07946" });

/ Append the reference to body, the element should be in a Run.
  wordDoc.MainDocumentPart.Document.Body.AppendChild(new Paragraph(new Run(element)));


(*
open System.IO
open System.IO.Packaging
open DocumentFormat.OpenXml.Packaging 
open DocumentFormat.OpenXml.Wordprocessing 

[<EntryPoint>] 
let Main args = 
    let byteArray = File.ReadAllBytes "Test.docx" 

    use mem = new MemoryStream() 
    mem.Write(byteArray, 0, (int)byteArray.Length) 

    do
        use doc = WordprocessingDocument.Open(mem, true) 
        let para = new Paragraph() 
        let run = new Run() 
        let text = new Text("Newly inserted paragraph") 
        run.InsertAt(text, 0) |> ignore     
        para.InsertAt(run, 0) |> ignore
        doc.MainDocumentPart.Document.Body.InsertAt(para, 0) |> ignore 

    use fs = new FileStream("Test2.docx", FileMode.Create) 
    mem.WriteTo(fs) 

    0 
*)


//let doc = WordprocessingDocument.Open((fileName:string), editable)